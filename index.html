<!DOCTYPE html>
<html lang="sv">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ren JavaScript Spel</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a1f;
            font-family: Arial, sans-serif;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        
        #game-container {
            width: 800px;
            height: 600px;
            position: relative;
        }
        
        #game-canvas {
            border: 2px solid #4fc3f7;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="800" height="600"></canvas>
    </div>
    
    <script>
    // H√§mta canvas och kontext
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // Bakgrundsstj√§rnor
    const stars = [];
    const STAR_COUNT = 100;
    
    // Spelarens egenskaper
    const player = {
        x: 400,
        y: 550,
        size: 20,
        speed: 5,
        dx: 0,
        dy: 0,
        invincible: false,
        powerUps: {
            doubleFire: false,
            fastFire: false,
            shield: false,
            autoTurret: false,
            piercingShots: false
        }
    };
    
    // Fiender
    const enemies = [];
    const ENEMY_TYPES = {
        BASIC: 'basic',
        FAST: 'fast',
        TANK: 'tank'
    };
    
    // Skott
    const bullets = [];
    const FIRE_RATE = 20;
    let fireCounter = 0;
    
    // Power-ups
    const powerUps = [];
    const POWERUP_TYPES = {
        DOUBLE_FIRE: 'doubleFire',
        FAST_FIRE: 'fastFire',
        SHIELD: 'shield',
        AUTO_TURRET: 'autoTurret',
        PIERCING_SHOTS: 'piercingShots'
    };
    const POWERUP_SPAWN_CHANCE = 0.1; // 10% chans att en fiende droppar en power-up
    
    // Tangenttryckningar
    const keys = {};
    
    // Lyssna p√• tangenttryckningar
    document.addEventListener('keydown', (e) => {
        keys[e.key] = true;
        
        // Skjut n√§r man trycker p√• mellanslag
        if (e.key === ' ' && !gameState.gameOver) {
            if (fireCounter <= 0) {
                fireBullet();
                fireCounter = player.powerUps.fastFire ? FIRE_RATE / 2 : FIRE_RATE;
            }
        }
    });
    
    document.addEventListener('keyup', (e) => {
        keys[e.key] = false;
    });
    
    // Speltillst√•nd
    const gameState = {
        score: 0,
        level: 1,
        lives: 3,
        gameOver: false
    };
    
    // Niv√•system
    const ENEMIES_PER_LEVEL = 10;
    let enemiesDefeated = 0;
    const SPAWN_RATE = 60; // Frames mellan fiendespawn
    let spawnCounter = 0;
    
    // L√§gg till turrets-array f√∂r att h√•lla reda p√• aktiva turrets
    const turrets = [];
    
    // L√§gg till f√∂ljande variabler f√∂r kombo-systemet i b√∂rjan av skriptet, efter andra variabler
    let comboCount = 0;
    let comboTimer = 0;
    const COMBO_TIME = 120; // 2 sekunder i 60 FPS
    let comboPoints = 0;
    let showComboMessage = false;
    let comboMessageTimer = 0;
    
    // L√§gg till achievement-objekt n√§ra b√∂rjan av skriptet
    const achievements = [
        { id: 'lvl5', title: 'Rymdresen√§r', description: 'N√• niv√• 5', unlocked: false, icon: 'üöÄ' },
        { id: 'score1000', title: 'Stj√§rnskott', description: 'Uppn√• 1000 po√§ng', unlocked: false, icon: '‚≠ê' },
        { id: 'combo10', title: 'Kombokn√§ckare', description: 'F√• en 10x kombo', unlocked: false, icon: 'üî•' },
        { id: 'kills50', title: 'Rymdhj√§lte', description: 'Besegra 50 fiender totalt', unlocked: false, icon: 'üëæ' },
        { id: 'allpowerups', title: 'Kraftpaket', description: 'Ha 3+ power-ups aktiva samtidigt', unlocked: false, icon: 'üí™' }
    ];
    
    // L√§gg till r√§knare f√∂r totalt antal besegrade fiender
    let totalEnemiesDefeated = 0;
    
    // L√§gg till en variabel f√∂r att visa achievement-meddelanden
    let showAchievementMessage = false;
    let achievementMessageTimer = 0;
    let currentAchievement = null;
    
    // L√§gg till variabler f√∂r utmaningar
    const CHALLENGE_TYPES = {
        KILL_FAST: 'Besegra 5 fiender p√• 10 sekunder',
        DODGE: 'Undvik att skjuta i 5 sekunder',
        BOTTOM_SCREEN: 'H√•ll dig p√• nedre halvan av sk√§rmen i 5 sekunder'
    };

    let activeChallenge = null;
    let challengeProgress = 0;
    let challengeTimer = 0;
    let challengeCompleted = false;
    let challengeMessageTimer = 0;
    let lastChallengeLevel = 0;
    
    // Till√§gg √∂verst i skriptdelen, efter andra globala variabler
    let lastTime = 0;
    let deltaTime = 0;
    
    // L√§gg till denna variabel √∂verst i skriptet
    let gameTime = 0;
    
    // 1. L√§gg till en array f√∂r att h√•lla spelartr√§ff-effekter
    let hitEffects = [];
    
    // Skapa stj√§rnor
    function createStars() {
        for (let i = 0; i < STAR_COUNT; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 3,
                speed: 0.5 + Math.random() * 1.5
            });
        }
    }
    
    // Uppdatera stj√§rnor
    function updateStars() {
        for (let i = 0; i < stars.length; i++) {
            // Konvertera pixlar per frame till pixlar per sekund
            const starSpeedPerSecond = stars[i].speed * 60;
            stars[i].y += starSpeedPerSecond * deltaTime;
            
            // √Öterst√§ll stj√§rnans position n√§r den l√§mnar sk√§rmen
            if (stars[i].y > canvas.height) {
                stars[i].y = 0;
                stars[i].x = Math.random() * canvas.width;
            }
        }
    }
    
    // Rita stj√§rnor
    function drawStars() {
        ctx.fillStyle = "#ffffff";
        for (let i = 0; i < stars.length; i++) {
            ctx.fillRect(stars[i].x, stars[i].y, stars[i].size, stars[i].size);
        }
    }
    
    // Uppdatera spelarens position
    function updatePlayer() {
        // Om spelet √§r slut, kontrollera om spelaren vill b√∂rja om
        if (gameState.gameOver) {
            if (keys[' '] || keys['Space']) {
                resetGame();
            }
            return;
        }
        
        player.dx = 0;
        player.dy = 0;
        
        // Konvertera pixlar per frame till pixlar per sekund
        const playerSpeedPerSecond = player.speed * 60;
        
        if (keys['ArrowLeft'] || keys['a']) player.dx = -playerSpeedPerSecond * deltaTime;
        if (keys['ArrowRight'] || keys['d']) player.dx = playerSpeedPerSecond * deltaTime;
        if (keys['ArrowUp'] || keys['w']) player.dy = -playerSpeedPerSecond * deltaTime;
        if (keys['ArrowDown'] || keys['s']) player.dy = playerSpeedPerSecond * deltaTime;
        
        player.x += player.dx;
        player.y += player.dy;
        
        // Begr√§nsa spelaren till canvas
        player.x = Math.max(player.size, Math.min(player.x, canvas.width - player.size));
        player.y = Math.max(player.size, Math.min(player.y, canvas.height - player.size));
        
        // Uppdatera skottr√§knare baserat p√• deltaTime
        if (fireCounter > 0) {
            fireCounter -= deltaTime * 60; // Anpassa till frames
        }
    }
    
    // Rita spelaren
    function drawPlayer() {
        // Spara canvas-tillst√•nd f√∂r transformationer
        ctx.save();
        
        // Centrera p√• spelarens position
        ctx.translate(player.x, player.y);
        
        // L√§gg till en subtil gungande r√∂relse (anv√§nd gameTime ist√§llet f√∂r Date.now)
        const wobble = Math.sin(gameTime * 3) * 1.5; // 3 rad/sec
        ctx.rotate(wobble * 0.05);
        
        // Skapa en gradient f√∂r huvudkroppen
        const bodyGradient = ctx.createLinearGradient(0, -player.size, 0, player.size);
        bodyGradient.addColorStop(0, '#4fc3f7');
        bodyGradient.addColorStop(0.5, '#0288d1');
        bodyGradient.addColorStop(1, '#01579b');
        
        // Rita huvudkroppen (mer detaljerad form)
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.moveTo(0, -player.size);          // Nos
        ctx.lineTo(-player.size * 0.4, -player.size * 0.2); // V√§nster framkant
        ctx.lineTo(-player.size, player.size * 0.2);  // V√§nster vinge
        ctx.lineTo(-player.size * 0.6, player.size * 0.6); // V√§nster bakkant
        ctx.lineTo(-player.size * 0.3, player.size * 0.4); // V√§nster motorf√§ste
        ctx.lineTo(0, player.size * 0.7);     // Mitt bak
        ctx.lineTo(player.size * 0.3, player.size * 0.4); // H√∂ger motorf√§ste
        ctx.lineTo(player.size * 0.6, player.size * 0.6); // H√∂ger bakkant
        ctx.lineTo(player.size, player.size * 0.2);  // H√∂ger vinge
        ctx.lineTo(player.size * 0.4, -player.size * 0.2); // H√∂ger framkant
        ctx.closePath();
        ctx.fill();
        
        // Motorflammor (animerade)
        const flameTime = gameTime * 10; // 10 rad/sec
        
        // V√§nster motor
        const leftFlameSize = 10 + Math.sin(flameTime) * 5;
        const leftFlameGradient = ctx.createLinearGradient(
            -player.size * 0.3, player.size * 0.4,
            -player.size * 0.3, player.size * 0.4 + leftFlameSize
        );
        leftFlameGradient.addColorStop(0, '#ffffff');
        leftFlameGradient.addColorStop(0.3, '#64b5f6');
        leftFlameGradient.addColorStop(0.6, '#1976d2');
        leftFlameGradient.addColorStop(1, 'rgba(25, 118, 210, 0)');
        
        ctx.fillStyle = leftFlameGradient;
        ctx.beginPath();
        ctx.moveTo(-player.size * 0.4, player.size * 0.4);
        ctx.lineTo(-player.size * 0.3, player.size * 0.4 + leftFlameSize);
        ctx.lineTo(-player.size * 0.2, player.size * 0.4);
        ctx.closePath();
        ctx.fill();
        
        // H√∂ger motor
        const rightFlameSize = 10 + Math.sin(flameTime + 1) * 5;
        const rightFlameGradient = ctx.createLinearGradient(
            player.size * 0.3, player.size * 0.4,
            player.size * 0.3, player.size * 0.4 + rightFlameSize
        );
        rightFlameGradient.addColorStop(0, '#ffffff');
        rightFlameGradient.addColorStop(0.3, '#64b5f6');
        rightFlameGradient.addColorStop(0.6, '#1976d2');
        rightFlameGradient.addColorStop(1, 'rgba(25, 118, 210, 0)');
        
        ctx.fillStyle = rightFlameGradient;
        ctx.beginPath();
        ctx.moveTo(player.size * 0.2, player.size * 0.4);
        ctx.lineTo(player.size * 0.3, player.size * 0.4 + rightFlameSize);
        ctx.lineTo(player.size * 0.4, player.size * 0.4);
        ctx.closePath();
        ctx.fill();
        
        // Cockpit/f√∂nster
        const cockpitGradient = ctx.createRadialGradient(0, -player.size * 0.2, 1, 0, -player.size * 0.2, player.size * 0.4);
        cockpitGradient.addColorStop(0, '#e1f5fe');
        cockpitGradient.addColorStop(0.8, '#29b6f6');
        cockpitGradient.addColorStop(1, '#0288d1');
        
        ctx.fillStyle = cockpitGradient;
        ctx.beginPath();
        ctx.ellipse(0, -player.size * 0.2, player.size * 0.25, player.size * 0.4, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Detaljer p√• vingarna
        ctx.strokeStyle = '#b3e5fc';
        ctx.lineWidth = 2;
        
        // V√§nster vingdetalj
        ctx.beginPath();
        ctx.moveTo(-player.size * 0.4, -player.size * 0.1);
        ctx.lineTo(-player.size * 0.8, player.size * 0.1);
        ctx.stroke();
        
        // H√∂ger vingdetalj
        ctx.beginPath();
        ctx.moveTo(player.size * 0.4, -player.size * 0.1);
        ctx.lineTo(player.size * 0.8, player.size * 0.1);
        ctx.stroke();
        
        // Ljuseffekter p√• skeppet
        ctx.fillStyle = '#e1f5fe';
        
        // Nos-ljus
        ctx.beginPath();
        ctx.arc(0, -player.size * 0.9, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Vingspets-ljus
        ctx.beginPath();
        ctx.arc(-player.size * 0.95, player.size * 0.15, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(player.size * 0.95, player.size * 0.15, 2, 0, Math.PI * 2);
        ctx.fill();
        
        // Os√•rbarhetsblinkning
        if (player.invincible && Math.floor(gameTime * 100) % 2) {
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(0, 0, player.size * 1.2, 0, Math.PI * 2);
            ctx.fill();
        }
        
        // Rita sk√∂ld om aktiv
        if (player.powerUps.shield) {
            const shieldGlow = 0.5 + Math.sin(gameTime * 200) * 0.2;
            const shieldGradient = ctx.createRadialGradient(0, 0, player.size, 0, 0, player.size + 15);
            shieldGradient.addColorStop(0, `rgba(0, 255, 255, 0)`);
            shieldGradient.addColorStop(0.5, `rgba(0, 255, 255, ${shieldGlow * 0.2})`);
            shieldGradient.addColorStop(0.8, `rgba(0, 255, 255, ${shieldGlow * 0.5})`);
            shieldGradient.addColorStop(1, `rgba(0, 255, 255, 0)`);
            
            ctx.fillStyle = shieldGradient;
            ctx.beginPath();
            ctx.arc(0, 0, player.size + 15, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.strokeStyle = `rgba(0, 255, 255, ${shieldGlow})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, player.size + 10, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // √Öterst√§ll canvas-tillst√•nd
        ctx.restore();
    }
    
    // Skapa en ny fiende
    function spawnEnemy() {
        // Slumpm√§ssigt v√§lja fiendtyp baserat p√• niv√•
        let type, size, speed, health, color, points;
        
        const rand = Math.random();
        
        if (rand < 0.1 + gameState.level * 0.02) {
            // Tank (s√§llsynt i b√∂rjan, vanligare p√• h√∂gre niv√•er)
            type = ENEMY_TYPES.TANK;
            size = 30;
            speed = 1;
            health = 3;
            color = '#ff9800';
            points = 30;
        } else if (rand < 0.3 + gameState.level * 0.03) {
            // Fast (n√•got vanligare)
            type = ENEMY_TYPES.FAST;
            size = 15;
            speed = 3;
            health = 1;
            color = '#00ff00';
            points = 20;
        } else {
            // Basic (vanligast)
            type = ENEMY_TYPES.BASIC;
            size = 20;
            speed = 2;
            health = 1;
            color = '#ff0000';
            points = 10;
        }
        
        const enemy = {
            x: Math.random() * (canvas.width - size * 2) + size,
            y: -size,
            size: size,
            speed: speed,
            health: health,
            maxHealth: health,
            type: type,
            color: color,
            points: points
        };
        
        enemies.push(enemy);
    }
    
    // Uppdatera fiender
    function updateEnemies() {
        // Uppdatera befintliga fiender
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            
            // Konvertera pixlar per frame till pixlar per sekund
            const enemySpeedPerSecond = enemy.speed * 60;
            
            // Flytta fienden ned√•t
            enemy.y += enemySpeedPerSecond * deltaTime;
            
            // Ta bort fiender som l√§mnar sk√§rmen
            if (enemy.y > canvas.height + enemy.size) {
                enemies.splice(i, 1);
            }
        }
        
        // Skapa nya fiender baserat p√• deltaTime
        spawnCounter -= deltaTime * 60; // Anpassa till frames
        
        if (spawnCounter <= 0) {
            spawnEnemy();
            spawnCounter = SPAWN_RATE;
        }
    }
    
    // Rita fiender
    function drawEnemies() {
        for (let enemy of enemies) {
            // V√§lj ritfunktion baserat p√• fiendtyp
            if (enemy.type === ENEMY_TYPES.BASIC) {
                drawBasicEnemy(enemy);
            } else if (enemy.type === ENEMY_TYPES.FAST) {
                drawFastEnemy(enemy);
            } else if (enemy.type === ENEMY_TYPES.TANK) {
                drawTankEnemy(enemy);
            }
        }
    }
    
    // Rita basic-fiende
    function drawBasicEnemy(enemy) {
        // Spara canvas-tillst√•nd f√∂r transformationer
        ctx.save();
        
        // Centrera p√• fiendens position
        ctx.translate(enemy.x, enemy.y);
        
        // L√§gg till en gungande r√∂relse som ser lite klumpig ut
        const wobble = Math.sin(gameTime * 3 + enemy.x) * 3;
        const tilt = Math.cos(gameTime * 5) * 0.2;
        ctx.rotate(tilt);
        ctx.translate(wobble, 0);
        
        // Huvudkropp - en rund, lite tillplattad form
        const bodyGradient = ctx.createRadialGradient(0, 0, 5, 0, 0, enemy.size);
        bodyGradient.addColorStop(0, '#ff9966');
        bodyGradient.addColorStop(0.6, '#ff6633');
        bodyGradient.addColorStop(1, '#cc3300');
        
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.ellipse(0, 0, enemy.size, enemy.size * 0.8, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // √ñgon (stora, uttrycksfulla)
        const eyeSize = enemy.size * 0.3;
        const eyeDistance = enemy.size * 0.4;
        
        // √ñgonvitor
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(-eyeDistance, -enemy.size * 0.1, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(eyeDistance, -enemy.size * 0.1, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupiller (r√∂r sig runt lite slumpm√§ssigt)
        const pupilOffset = Math.sin(gameTime * 1000) * (eyeSize * 0.3);
        const pupilOffsetY = Math.cos(gameTime * 800) * (eyeSize * 0.3);
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(-eyeDistance + pupilOffset, -enemy.size * 0.1 + pupilOffsetY, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(eyeDistance + pupilOffset, -enemy.size * 0.1 + pupilOffsetY, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // √ñgonbryn (√§ndrar uttryck baserat p√• tid)
        const browAngle = Math.sin(gameTime * 2000) * 0.5;
        ctx.strokeStyle = '#cc3300';
        ctx.lineWidth = 3;
        
        // V√§nster √∂gonbryn
        ctx.beginPath();
        ctx.moveTo(-eyeDistance - eyeSize, -enemy.size * 0.3 + browAngle * 5);
        ctx.lineTo(-eyeDistance + eyeSize, -enemy.size * 0.3 - browAngle * 5);
        ctx.stroke();
        
        // H√∂ger √∂gonbryn
        ctx.beginPath();
        ctx.moveTo(eyeDistance - eyeSize, -enemy.size * 0.3 - browAngle * 5);
        ctx.lineTo(eyeDistance + eyeSize, -enemy.size * 0.3 + browAngle * 5);
        ctx.stroke();
        
        // Mun (√§ndrar form √∂ver tid)
        const mouthWidth = enemy.size * 0.7;
        const mouthHeight = enemy.size * 0.2 + Math.sin(gameTime * 500) * enemy.size * 0.1;
        
        ctx.fillStyle = '#990000';
        ctx.beginPath();
        ctx.ellipse(0, enemy.size * 0.3, mouthWidth, mouthHeight, 0, 0, Math.PI);
        ctx.fill();
        
        // T√§nder (komiskt stora)
        ctx.fillStyle = '#ffffff';
        const teethCount = 4;
        const teethWidth = mouthWidth * 2 / teethCount;
        
        for (let i = 0; i < teethCount; i++) {
            const teethX = -mouthWidth + teethWidth * (i + 0.5);
            ctx.fillRect(teethX, enemy.size * 0.3, teethWidth * 0.7, enemy.size * 0.15);
        }
        
        // Antenner (vippande)
        const antennaWobble = Math.sin(gameTime * 200) * 0.3;
        ctx.strokeStyle = '#cc3300';
        ctx.lineWidth = 2;
        
        // V√§nster antenn
        ctx.beginPath();
        ctx.moveTo(-enemy.size * 0.5, -enemy.size * 0.5);
        ctx.quadraticCurveTo(
            -enemy.size * 0.7, -enemy.size * 0.8 + antennaWobble * 10,
            -enemy.size * 0.9, -enemy.size * 0.7
        );
        ctx.stroke();
        
        // H√∂ger antenn
        ctx.beginPath();
        ctx.moveTo(enemy.size * 0.5, -enemy.size * 0.5);
        ctx.quadraticCurveTo(
            enemy.size * 0.7, -enemy.size * 0.8 - antennaWobble * 10,
            enemy.size * 0.9, -enemy.size * 0.7
        );
        ctx.stroke();
        
        // Antennbollar
        ctx.fillStyle = '#ff3300';
        ctx.beginPath();
        ctx.arc(-enemy.size * 0.9, -enemy.size * 0.7, enemy.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(enemy.size * 0.9, -enemy.size * 0.7, enemy.size * 0.15, 0, Math.PI * 2);
        ctx.fill();
        
        // Sm√• armar som viftar
        const armWave = Math.sin(gameTime * 300) * 0.5;
        
        // V√§nster arm
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-enemy.size * 0.8, 0);
        ctx.quadraticCurveTo(
            -enemy.size * 1.2, enemy.size * 0.2,
            -enemy.size * 1.1, enemy.size * 0.4 + armWave * 10
        );
        ctx.stroke();
        
        // H√∂ger arm
        ctx.beginPath();
        ctx.moveTo(enemy.size * 0.8, 0);
        ctx.quadraticCurveTo(
            enemy.size * 1.2, enemy.size * 0.2,
            enemy.size * 1.1, enemy.size * 0.4 - armWave * 10
        );
        ctx.stroke();
        
        // Sm√• h√§nder
        ctx.fillStyle = '#ff6633';
        ctx.beginPath();
        ctx.arc(-enemy.size * 1.1, enemy.size * 0.4 + armWave * 10, enemy.size * 0.12, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(enemy.size * 1.1, enemy.size * 0.4 - armWave * 10, enemy.size * 0.12, 0, Math.PI * 2);
        ctx.fill();
        
        // √Öterst√§ll canvas-tillst√•nd
        ctx.restore();
    }
    
    // √Öterst√§ll drawFastEnemy till en enklare version som fungerar
    function drawFastEnemy(enemy) {
        // Spara canvas-tillst√•nd
        ctx.save();
        
        // Centrera p√• fiendens position
        ctx.translate(enemy.x, enemy.y);
        
        // L√§gg till en enkel vibration f√∂r hastighet
        const vibration = Math.sin(gameTime * 100) * 2;
        ctx.translate(vibration, 0);
        
        // Rita en gr√∂n cirkel f√∂r fast-fiender
        const gradient = ctx.createRadialGradient(0, 0, enemy.size * 0.3, 0, 0, enemy.size);
        gradient.addColorStop(0, '#33cc33');
        gradient.addColorStop(1, '#006600');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, enemy.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Rita ett stort √∂ga
        const eyeSize = enemy.size * 0.6;
        
        // √ñgonvita
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(0, -enemy.size * 0.1, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupill
        const pupilOffset = Math.sin(gameTime * 500) * (eyeSize * 0.3);
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(pupilOffset, -enemy.size * 0.1, eyeSize * 0.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Visa h√§lsoindikator f√∂r fiender med mer √§n 1 HP
        if (enemy.maxHealth > 1) {
            const healthWidth = enemy.size * 2;
            const healthHeight = 4;
            const healthX = -healthWidth / 2;
            const healthY = -enemy.size - 10;
            
            // Bakgrund f√∂r h√§lsom√§tare
            ctx.fillStyle = '#333333';
            ctx.fillRect(healthX, healthY, healthWidth, healthHeight);
            
            // Faktiskt h√§lsa
            const healthPercent = enemy.health / enemy.maxHealth;
            ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
            ctx.fillRect(healthX, healthY, healthWidth * healthPercent, healthHeight);
        }
        
        // √Öterst√§ll canvas-tillst√•nd
        ctx.restore();
    }
    
    // Rita tank-fiende
    function drawTankEnemy(enemy) {
        // Spara canvas-tillst√•nd
        ctx.save();
        
        // Centrera p√• fiendens position
        ctx.translate(enemy.x, enemy.y);
        
        // L√§gg till en tung, l√•ngsam gungning
        const wobble = Math.sin(gameTime * 500) * 2;
        ctx.translate(wobble, 0);
        
        // Huvudkropp - stor, kraftig bl√• form
        const bodyGradient = ctx.createRadialGradient(0, 0, enemy.size * 0.3, 0, 0, enemy.size);
        bodyGradient.addColorStop(0, '#4466ff');
        bodyGradient.addColorStop(0.7, '#2244cc');
        bodyGradient.addColorStop(1, '#112266');
        
        ctx.fillStyle = bodyGradient;
        ctx.beginPath();
        ctx.arc(0, 0, enemy.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Rustning/pansar p√• kroppen
        ctx.fillStyle = '#001155';
        
        // √ñvre pansarpl√•t
        ctx.beginPath();
        ctx.arc(0, -enemy.size * 0.5, enemy.size * 0.7, Math.PI, Math.PI * 2);
        ctx.fill();
        
        // Nedre pansarpl√•t
        ctx.beginPath();
        ctx.arc(0, enemy.size * 0.5, enemy.size * 0.7, 0, Math.PI);
        ctx.fill();
        
        // Sidopansar (v√§nster)
        ctx.beginPath();
        ctx.ellipse(-enemy.size * 0.7, 0, enemy.size * 0.3, enemy.size * 0.8, 0, -Math.PI/2, Math.PI/2);
        ctx.fill();
        
        // Sidopansar (h√∂ger)
        ctx.beginPath();
        ctx.ellipse(enemy.size * 0.7, 0, enemy.size * 0.3, enemy.size * 0.8, 0, Math.PI/2, -Math.PI/2);
        ctx.fill();
        
        // √ñgon (tv√• sm√•, arga)
        const eyeSize = enemy.size * 0.2;
        const eyeDistance = enemy.size * 0.3;
        const eyeY = -enemy.size * 0.15;
        
        // √ñgonvitor
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(-eyeDistance, eyeY, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(eyeDistance, eyeY, eyeSize, 0, Math.PI * 2);
        ctx.fill();
        
        // Pupiller (r√∂r sig lite, ser arga ut)
        const pupilOffset = Math.sin(gameTime * 800) * (eyeSize * 0.2);
        
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(-eyeDistance + pupilOffset, eyeY, eyeSize * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.beginPath();
        ctx.arc(eyeDistance + pupilOffset, eyeY, eyeSize * 0.6, 0, Math.PI * 2);
        ctx.fill();
        
        // √ñgonbryn (arga)
        ctx.strokeStyle = '#001155';
        ctx.lineWidth = 4;
        
        // V√§nster √∂gonbryn
        ctx.beginPath();
        ctx.moveTo(-eyeDistance - eyeSize * 1.2, eyeY - eyeSize * 1.2);
        ctx.lineTo(-eyeDistance + eyeSize * 0.8, eyeY - eyeSize * 0.5);
        ctx.stroke();
        
        // H√∂ger √∂gonbryn
        ctx.beginPath();
        ctx.moveTo(eyeDistance - eyeSize * 0.8, eyeY - eyeSize * 0.5);
        ctx.lineTo(eyeDistance + eyeSize * 1.2, eyeY - eyeSize * 1.2);
        ctx.stroke();
        
        // Mun (arg, med t√§nder)
        const mouthWidth = enemy.size * 0.6;
        const mouthHeight = enemy.size * 0.2;
        const mouthY = enemy.size * 0.3;
        
        // Munnens form
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.ellipse(0, mouthY, mouthWidth, mouthHeight, 0, 0, Math.PI);
        ctx.fill();
        
        // T√§nder (stora, hotfulla)
        ctx.fillStyle = '#ffffff';
        const teethCount = 3;
        const teethWidth = mouthWidth * 2 / (teethCount * 2);
        
        for (let i = 0; i < teethCount; i++) {
            const teethX = -mouthWidth + teethWidth * (i * 2 + 1);
            ctx.fillRect(teethX, mouthY - mouthHeight * 0.8, teethWidth, mouthHeight * 0.8);
        }
        
        // Kraftf√§lt/sk√∂ld-effekt (pulserande)
        if (enemy.health > enemy.maxHealth / 2) {
            const shieldPulse = 0.3 + Math.sin(gameTime * 300) * 0.1;
            ctx.strokeStyle = `rgba(100, 150, 255, ${shieldPulse})`;
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            ctx.arc(0, 0, enemy.size * 1.2, 0, Math.PI * 2);
            ctx.stroke();
            
            // Sm√• sk√∂ldsparks
            if (Math.random() < 0.1) {
                const sparkAngle = Math.random() * Math.PI * 2;
                const sparkDist = enemy.size * 1.2;
                const sparkX = Math.cos(sparkAngle) * sparkDist;
                const sparkY = Math.sin(sparkAngle) * sparkDist;
                const sparkSize = 2 + Math.random() * 4;
                
                ctx.fillStyle = 'rgba(150, 200, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Visa h√§lsoindikator
        const healthWidth = enemy.size * 2;
        const healthHeight = 6;
        const healthX = -healthWidth / 2;
        const healthY = -enemy.size - 15;
        
        // Bakgrund f√∂r h√§lsom√§tare
        ctx.fillStyle = '#333333';
        ctx.fillRect(healthX, healthY, healthWidth, healthHeight);
        
        // Faktiskt h√§lsa
        const healthPercent = enemy.health / enemy.maxHealth;
        ctx.fillStyle = healthPercent > 0.5 ? '#00ff00' : healthPercent > 0.25 ? '#ffff00' : '#ff0000';
        ctx.fillRect(healthX, healthY, healthWidth * healthPercent, healthHeight);
        
        // √Öterst√§ll canvas-tillst√•nd
        ctx.restore();
    }
    
    // Avfyra skott
    function fireBullet() {
        const bulletSpeed = 10;
        const bulletSize = 5;
        
        // Skapa ett nytt skott
        const newBullet = {
            x: player.x,
            y: player.y - player.size,
            size: bulletSize,
            speed: bulletSpeed,
            piercing: player.powerUps.piercingShots // Ny egenskap f√∂r genomtr√§ngande skott
        };
        
        // Om spelaren har genomtr√§ngande skott, √§ndra utseendet
        if (player.powerUps.piercingShots) {
            newBullet.size = 3; // Tunnare
            newBullet.height = 15; // L√§ngre
            newBullet.color = '#ffcc00'; // Gul f√§rg
        }
        
        // L√§gg till skottet i arrayen
        bullets.push(newBullet);
        
        // Om spelaren har dubbel eld, skapa ett till skott
        if (player.powerUps.doubleFire) {
            const secondBullet = {
                x: player.x,
                y: player.y - player.size,
                size: bulletSize,
                speed: bulletSpeed,
                piercing: player.powerUps.piercingShots
            };
            
            // Om spelaren har genomtr√§ngande skott, √§ndra utseendet
            if (player.powerUps.piercingShots) {
                secondBullet.size = 3;
                secondBullet.height = 15;
                secondBullet.color = '#ffcc00';
            }
            
            // L√§gg till det andra skottet
            bullets.push(secondBullet);
            
            // Placera skotten bredvid varandra
            newBullet.x -= 10;
            secondBullet.x += 10;
        }
    }
    
    // Uppdatera skott
    function updateBullets() {
        for (let i = bullets.length - 1; i >= 0; i--) {
            // Konvertera pixlar per frame till pixlar per sekund
            const bulletSpeedPerSecond = bullets[i].speed * 60;
            
            // Flytta skottet upp√•t
            bullets[i].y -= bulletSpeedPerSecond * deltaTime;
            
            // Ta bort skott som l√§mnar sk√§rmen
            if (bullets[i].y < -bullets[i].size) {
                bullets.splice(i, 1);
            }
        }
    }
    
    // Rita skott
    function drawBullets() {
        for (let bullet of bullets) {
            // Best√§m f√§rg baserat p√• typ
            if (bullet.color) {
                ctx.fillStyle = bullet.color;
            } else if (bullet.piercing) {
                ctx.fillStyle = '#ffcc00'; // Gul f√∂r genomtr√§ngande skott
            } else {
                ctx.fillStyle = '#ffffff'; // Vit f√∂r vanliga skott
            }
            
            // Rita skott baserat p√• typ
            if (bullet.piercing) {
                // Rita genomtr√§ngande skott (l√§ngre, tunnare)
                ctx.fillRect(bullet.x - bullet.size / 2, bullet.y - bullet.height / 2, bullet.size, bullet.height);
                
                // L√§gg till ljussp√•r
                const trailGradient = ctx.createLinearGradient(
                    bullet.x, bullet.y + bullet.height / 2,
                    bullet.x, bullet.y - bullet.height / 2
                );
                trailGradient.addColorStop(0, 'rgba(255, 204, 0, 0)');
                trailGradient.addColorStop(0.5, 'rgba(255, 204, 0, 0.5)');
                trailGradient.addColorStop(1, 'rgba(255, 204, 0, 0.8)');
                
                ctx.fillStyle = trailGradient;
                ctx.fillRect(bullet.x - bullet.size, bullet.y, bullet.size * 2, bullet.height / 2);
            } else {
                // Rita vanligt skott (cirkel)
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, bullet.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
    
    // Skapa power-up
    function spawnPowerUp(x, y) {
        // V√§lj en slumpm√§ssig power-up typ
        const types = Object.values(POWERUP_TYPES);
        const randomType = types[Math.floor(Math.random() * types.length)];
        
        // Best√§m f√§rg baserat p√• typ
        let color;
        switch (randomType) {
            case POWERUP_TYPES.DOUBLE_FIRE:
                color = '#ff9900'; // Orange/gul
                break;
            case POWERUP_TYPES.FAST_FIRE:
                color = '#00ff00'; // Gr√∂n
                break;
            case POWERUP_TYPES.SHIELD:
                color = '#00ffff'; // Cyan
                break;
            case POWERUP_TYPES.AUTO_TURRET:
                color = '#ff6600'; // Orange
                break;
            case POWERUP_TYPES.PIERCING_SHOTS:
                color = '#ffcc00'; // Gul
                break;
        }
        
        // Skapa power-up objekt
        const powerUp = {
            x: x,
            y: y,
            size: 10,
            speed: 2,
            type: randomType,
            color: color
        };
        
        // L√§gg till i power-ups array
        powerUps.push(powerUp);
    }
    
    // Uppdatera power-ups
    function updatePowerUps() {
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];
            
            // Konvertera pixlar per frame till pixlar per sekund
            const powerUpSpeedPerSecond = powerUp.speed * 60;
            
            // Flytta power-up ned√•t
            powerUp.y += powerUpSpeedPerSecond * deltaTime;
            
            // Ta bort power-up som l√§mnar sk√§rmen
            if (powerUp.y > canvas.height + powerUp.size) {
                powerUps.splice(i, 1);
            }
        }
    }
    
    // Rita power-ups
    function drawPowerUps() {
        for (let powerUp of powerUps) {
            ctx.fillStyle = powerUp.color;
            
            // Rita en diamant
            ctx.beginPath();
            ctx.moveTo(powerUp.x, powerUp.y - powerUp.size);
            ctx.lineTo(powerUp.x + powerUp.size, powerUp.y);
            ctx.lineTo(powerUp.x, powerUp.y + powerUp.size);
            ctx.lineTo(powerUp.x - powerUp.size, powerUp.y);
            ctx.closePath();
            ctx.fill();
        }
    }
    
    // √Ñndra checkCollisions() till att endast hantera skott-fiende-kollisioner
    function checkCollisions() {
        // Kontrollera kollisioner mellan skott och fiender
        for (let i = bullets.length - 1; i >= 0; i--) {
            const bullet = bullets[i];
            let bulletHit = false;
            
            for (let j = enemies.length - 1; j >= 0; j--) {
                const enemy = enemies[j];
                
                const distance = Math.sqrt(
                    Math.pow(bullet.x - enemy.x, 2) + 
                    Math.pow(bullet.y - enemy.y, 2)
                );
                
                if (distance < bullet.size + enemy.size) {
                    // Tr√§ff! Minska fiendens h√§lsa
                    enemy.health--;
                    
                    // Om fienden √§r d√∂d
                    if (enemy.health <= 0) {
                        // Slumpm√§ssig chans att fienden droppar en power-up
                        if (Math.random() < POWERUP_SPAWN_CHANCE) {
                            spawnPowerUp(enemy.x, enemy.y);
                        }
                        
                        // Ta bort fienden
                        enemies.splice(j, 1);
                        
                        // √ñka po√§ng baserat p√• fiendtyp
                        gameState.score += enemy.points;
                        
                        // √ñka antal besegrade fiender
                        enemiesDefeated++;
                        
                        // Kolla om det √§r dags att g√• upp en niv√•
                        if (enemiesDefeated >= ENEMIES_PER_LEVEL) {
                            levelUp();
                        }
                        
                        // Uppdatera kombo
                        comboCount++;
                        comboTimer = COMBO_TIME;
                        
                        // L√§gg till detta inuti if (enemy.health <= 0) { ... }, precis efter enemiesDefeated++;
                        totalEnemiesDefeated++;

                        // Uppdatera kill-challenge om aktiv
                        if (activeChallenge && activeChallenge.type === CHALLENGE_TYPES.KILL_FAST) {
                            challengeProgress++;
                        }
                    }
                    
                    // Om skottet inte √§r genomtr√§ngande, ta bort det
                    if (!bullet.piercing) {
                        bullets.splice(i, 1);
                        bulletHit = true;
                        break; // Avsluta inre loopen eftersom skottet √§r borta
                    }
                    // Annars forts√§tt loopen f√∂r att l√•ta skottet tr√§ffa fler fiender
                }
            }
            
            // Om skottet redan har tagits bort, hoppa √∂ver resten
            if (bulletHit) continue;
        }
    }
    
    // Modifiera checkPlayerCollisions() f√∂r att inkludera explosionseffekten
    function checkPlayerCollisions() {
        // Om spelaren √§r os√•rbar, kontrollera inte fiendekollisioner
        if (!player.invincible) {
            // Kontrollera kollision med fiender
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                const distance = Math.sqrt(
                    Math.pow(player.x - enemy.x, 2) + 
                    Math.pow(player.y - enemy.y, 2)
                );
                
                if (distance < player.size + enemy.size) {
                    // L√ÑGG TILL EXPLOSIONSEFFEKTEN H√ÑR
                    createPlayerHitExplosion(player.x, player.y);
                    
                    // Kollision! Om spelaren har sk√∂ld, f√∂rst√∂r fienden
                    if (player.powerUps.shield) {
                        player.powerUps.shield = false; // Ta bort sk√∂lden
                        enemies.splice(i, 1); // Ta bort fienden
                    } else {
                        // Minska spelarens liv
                        gameState.lives--;
                        
                        // Kontrollera om spelet √§r slut
                        if (gameState.lives <= 0) {
                            gameState.gameOver = true;
                        } else {
                            // G√∂r spelaren os√•rbar en stund
                            player.invincible = true;
                            setTimeout(() => player.invincible = false, 2000);
                        }
                        
                        // Ta bort fienden
                        enemies.splice(i, 1);
                    }
                    
                    // √Öterst√§ll kombo
                    comboCount = 0;
                    comboTimer = 0;
                    
                    break;
                }
            }
        }
        
        // Kontrollera kollision med power-ups
        for (let i = powerUps.length - 1; i >= 0; i--) {
            const powerUp = powerUps[i];
            
            const distance = Math.sqrt(
                Math.pow(player.x - powerUp.x, 2) + 
                Math.pow(player.y - powerUp.y, 2)
            );
            
            if (distance < player.size + powerUp.size) {
                // Aktivera power-up
                player.powerUps[powerUp.type] = true;
                
                // S√§rskild hantering f√∂r auto turret
                if (powerUp.type === POWERUP_TYPES.AUTO_TURRET && turrets.length === 0) {
                    createTurret();
                }
                
                // S√§tt timer f√∂r att inaktivera power-up efter en tid (utom sk√∂ld)
                if (powerUp.type !== POWERUP_TYPES.SHIELD) {
                    const duration = powerUp.type === POWERUP_TYPES.AUTO_TURRET ? 12000 : 10000;
                    
                    setTimeout(() => {
                        player.powerUps[powerUp.type] = false;
                    }, duration);
                }
                
                // Ta bort power-up
                powerUps.splice(i, 1);
            }
        }
    }
    
    // Rita game over-sk√§rmen
    function drawGameOver() {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '48px Arial Bold';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 50);
        
        ctx.font = '24px Arial';
        ctx.fillText(`Din po√§ng: ${gameState.score}`, canvas.width / 2, canvas.height / 2 + 20);
        ctx.fillText('Tryck p√• MELLANSLAG f√∂r att spela igen', canvas.width / 2, canvas.height / 2 + 70);
        
        // √Öterst√§ll textjustering
        ctx.textAlign = 'left';
    }
    
    // √Öterst√§ll spelet f√∂r att b√∂rja om
    function resetGame() {
        // √Öterst√§ll spelarposition
        player.x = canvas.width / 2;
        player.y = canvas.height - 50;
        player.invincible = false;
        player.speed = 5;
        player.powerUps = {
            doubleFire: false,
            fastFire: false,
            shield: false,
            autoTurret: false,
            piercingShots: false
        };
        
        // √Öterst√§ll spelvariabler
        gameState.score = 0;
        gameState.lives = 3;
        gameState.level = 1;
        gameState.gameOver = false;
        
        // √Öterst√§ll niv√•variabler
        enemiesDefeated = 0;
        spawnCounter = 0;
        
        // √Öterst√§ll fiender och skott
        enemies.length = 0;
        bullets.length = 0;
        powerUps.length = 0;
        turrets.length = 0;
        
        // Reset achievements
        for (let achievement of achievements) {
            achievement.unlocked = false;
        }
        comboCount = 0;
        comboTimer = 0;
        comboPoints = 0;
        showComboMessage = false;
        comboMessageTimer = 0;
        totalEnemiesDefeated = 0;
        showAchievementMessage = false;
        achievementMessageTimer = 0;
        currentAchievement = null;
    }
    
    // Funktion f√∂r att g√• upp en niv√•
    function levelUp() {
        gameState.level++;
        enemiesDefeated = 0;
        
        // Visa meddelande om ny niv√•
        levelMessage = `NIV√Ö ${gameState.level}!`;
        levelMessageTimer = 180; // Visa i 3 sekunder
        
        // √ñka spelarens hastighet n√•got f√∂r varje niv√• (upp till en gr√§ns)
        if (player.speed < 8) {
            player.speed += 0.2;
        }
    }
    
    // Visa niv√•meddelande
    let levelMessage = "";
    let levelMessageTimer = 0;
    
    // Skapa en funktion f√∂r att hantera turrets
    function createTurret() {
        // Skapa tv√• turrets
        for (let i = 0; i < 2; i++) {
            const angle = i * Math.PI; // Placera dem p√• motsatta sidor
            
            const turret = {
                angle: angle,
                distance: 40, // Avst√•nd fr√•n spelaren
                rotationSpeed: 0.02, // Hur snabbt de roterar runt spelaren
                fireCounter: 0,
                fireRate: 60, // Skjuter var 60:e frame
                size: 8
            };
            
            turrets.push(turret);
        }
    }
    
    // Uppdatera turrets
    function updateTurrets() {
        // Om spelaren inte har auto turret power-up, t√∂m arrayen
        if (!player.powerUps.autoTurret) {
            turrets.length = 0;
            return;
        }
        
        // Uppdatera varje turret
        for (let turret of turrets) {
            // Uppdatera position (rotera runt spelaren)
            turret.angle += turret.rotationSpeed;
            
            // Uppdatera skjutning
            turret.fireCounter++;
            if (turret.fireCounter >= turret.fireRate) {
                // Skjut ett skott
                const turretX = player.x + Math.cos(turret.angle) * turret.distance;
                const turretY = player.y + Math.sin(turret.angle) * turret.distance;
                
                const bullet = {
                    x: turretX,
                    y: turretY - 10,
                    size: 4,
                    speed: 8,
                    fromTurret: true,
                    color: '#ff6600' // Orange f√§rg f√∂r turret-skott
                };
                
                bullets.push(bullet);
                turret.fireCounter = 0;
            }
        }
    }
    
    // Rita turrets
    function drawTurrets() {
        if (!player.powerUps.autoTurret) return;
        
        for (let turret of turrets) {
            // Ber√§kna position
            const x = player.x + Math.cos(turret.angle) * turret.distance;
            const y = player.y + Math.sin(turret.angle) * turret.distance;
            
            // Rita turret
            ctx.save();
            ctx.translate(x, y);
            
            // Kropp
            const bodyGradient = ctx.createRadialGradient(0, 0, 1, 0, 0, turret.size);
            bodyGradient.addColorStop(0, '#ffaa66');
            bodyGradient.addColorStop(1, '#ff6600');
            
            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.arc(0, 0, turret.size, 0, Math.PI * 2);
            ctx.fill();
            
            // Kanon
            ctx.fillStyle = '#cc5500';
            ctx.fillRect(-2, -turret.size - 5, 4, 8);
            
            // Gl√∂dande effekt
            const glowSize = turret.size * 1.3;
            const glowOpacity = 0.3 + Math.sin(gameTime * 200) * 0.1;
            
            ctx.fillStyle = `rgba(255, 150, 0, ${glowOpacity})`;
            ctx.beginPath();
            ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
    }
    
    // L√§gg till denna funktion f√∂r att hantera kombo-systemet
    function updateCombo() {
        // Minska kombo-timern om den √§r aktiv
        if (comboTimer > 0) {
            comboTimer -= deltaTime * 60; // Konvertera till frames
            
            // Om timern n√•r noll, √•terst√§ll kombon
            if (comboTimer <= 0 && comboCount > 2) {
                // Visa meddelande om kombon
                showComboMessage = true;
                comboMessageTimer = 120; // Visa i 2 sekunder
                
                // Ge bonuspo√§ng baserat p√• kombon
                const bonus = comboCount * comboCount * 10;
                gameState.score += bonus;
                comboPoints = bonus;
                
                // √Öterst√§ll kombo
                comboCount = 0;
            }
        }
        
        // Uppdatera kombo-meddelandetimern
        if (comboMessageTimer > 0) {
            comboMessageTimer -= deltaTime * 60; // Konvertera till frames
            if (comboMessageTimer <= 0) {
                showComboMessage = false;
            }
        }
    }
    
    // L√§gg till en funktion f√∂r att kontrollera achievements
    function checkAchievements() {
        // Tempor√§r array f√∂r nyligen uppl√•sta achievements
        const newlyUnlocked = [];
        
        // Kontrollera varje achievement
        for (let achievement of achievements) {
            if (!achievement.unlocked) {
                let unlocked = false;
                
                // Kontrollera olika typer av achievements
                switch (achievement.id) {
                    case 'lvl5':
                        if (gameState.level >= 5) unlocked = true;
                        break;
                    case 'score1000':
                        if (gameState.score >= 1000) unlocked = true;
                        break;
                    case 'combo10':
                        if (comboCount >= 10) unlocked = true;
                        break;
                    case 'kills50':
                        if (totalEnemiesDefeated >= 50) unlocked = true;
                        break;
                    case 'allpowerups':
                        let activePowerUps = 0;
                        for (let key in player.powerUps) {
                            if (player.powerUps[key]) activePowerUps++;
                        }
                        if (activePowerUps >= 3) unlocked = true;
                        break;
                }
                
                // Om achievement √§r uppl√•st, markera det
                if (unlocked) {
                    achievement.unlocked = true;
                    newlyUnlocked.push(achievement);
                    
                    // Ge bonus po√§ng
                    gameState.score += 100;
                }
            }
        }
        
        // Visa meddelande om n√•got achievement l√•stes upp
        if (newlyUnlocked.length > 0) {
            currentAchievement = newlyUnlocked[0]; // Visa bara det f√∂rsta om flera l√•stes upp samtidigt
            showAchievementMessage = true;
            achievementMessageTimer = 180; // Visa i 3 sekunder
        }
        
        // Uppdatera achievement-meddelandetimern
        if (achievementMessageTimer > 0) {
            achievementMessageTimer -= deltaTime * 60; // Konvertera till frames
            if (achievementMessageTimer <= 0) {
                showAchievementMessage = false;
            }
        }
    }
    
    // Funktion f√∂r att skapa en ny utmaning
    function createChallenge() {
        // V√§lj en slumpm√§ssig utmaningstyp
        const challengeTypes = Object.values(CHALLENGE_TYPES);
        const randomType = challengeTypes[Math.floor(Math.random() * challengeTypes.length)];
        
        // Skapa utmaning
        activeChallenge = {
            type: randomType,
            timeLimit: 600, // 10 sekunder
            target: randomType === CHALLENGE_TYPES.KILL_FAST ? 5 : 300, // 5 fiender eller 5 sekunder (300 frames)
            reward: 200 // Po√§ng f√∂r att klara utmaningen
        };
        
        challengeProgress = 0;
        challengeTimer = activeChallenge.timeLimit;
        challengeCompleted = false;
        challengeMessageTimer = 180; // Visa meddelande i 3 sekunder
    }
    
    // Funktion f√∂r att uppdatera aktiv utmaning
    function updateChallenge() {
        // Om det inte finns n√•gon aktiv utmaning och spelaren har kommit till en ny niv√•, skapa en
        if (!activeChallenge && !challengeCompleted && gameState.level > 1 && gameState.level !== lastChallengeLevel) {
            createChallenge();
            lastChallengeLevel = gameState.level;
            return;
        }
        
        // Om det inte finns n√•gon aktiv utmaning, avsluta
        if (!activeChallenge) return;
        
        // Uppdatera utmaningstimer
        challengeTimer--;
        
        // Kontrollera om utmaningstiden har g√•tt ut
        if (challengeTimer <= 0) {
            // Om utmaningen √§r klar
            if (challengeProgress >= activeChallenge.target) {
                challengeCompleted = true;
                gameState.score += activeChallenge.reward;
                challengeMessageTimer = 180; // Visa meddelande i 3 sekunder
            }
            
            // Avsluta utmaningen
            activeChallenge = null;
            return;
        }
        
        // Uppdatera framsteg baserat p√• typ
        switch (activeChallenge.type) {
            case CHALLENGE_TYPES.KILL_FAST:
                // Uppdateras i checkCollisions-funktionen
                break;
            case CHALLENGE_TYPES.DODGE:
                // √ñka framsteg om spelaren inte skjuter
                if (!keys[' ']) {
                    challengeProgress++;
                } else {
                    // √Öterst√§ll framsteg om spelaren skjuter
                    challengeProgress = 0;
                }
                break;
            case CHALLENGE_TYPES.BOTTOM_SCREEN:
                // √ñka framsteg om spelaren √§r p√• nedre halvan av sk√§rmen
                if (player.y > canvas.height / 2) {
                    challengeProgress++;
                } else {
                    // √Öterst√§ll framsteg om spelaren g√•r upp
                    challengeProgress = 0;
                }
                break;
        }
        
        // Kontrollera om utmaningen √§r klar
        if (challengeProgress >= activeChallenge.target) {
            challengeCompleted = true;
            gameState.score += activeChallenge.reward;
            challengeMessageTimer = 180; // Visa meddelande i 3 sekunder
            activeChallenge = null;
        }
        
        // Uppdatera meddelandetimer
        if (challengeMessageTimer > 0) {
            challengeMessageTimer -= deltaTime * 60; // Konvertera till frames
        }
    }
    
    // 2. Modifiera createPlayerHitExplosion f√∂r att l√§gga till i arrayen ist√§llet f√∂r egen loop
    function createPlayerHitExplosion(x, y) {
        // Parametrar f√∂r spelar-tr√§ff-explosion
        const numParticles = 25;
        const particleSpeed = 3;
        const particleSize = 5;
        
        // Skapa en explosionseffekt-objekt
        const hitEffect = {
            particles: [],
            flash: {
                x: x,
                y: y,
                size: 10,
                maxSize: 40,
                alpha: 1,
                growSpeed: 3
            },
            active: true
        };
        
        // Skapa partiklar i slumpm√§ssiga riktningar
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * particleSpeed + 1.5;
            
            // Anv√§nd mer livliga f√§rger
            let particleColor;
            const colorType = Math.random();
            
            if (colorType < 0.6) {
                // 60% chans f√∂r orange/r√∂d
                particleColor = `rgba(255, ${Math.floor(Math.random() * 100)}, 0, 1)`;
            } else if (colorType < 0.9) {
                // 30% chans f√∂r gul
                particleColor = `rgba(255, ${Math.floor(Math.random() * 55) + 200}, 0, 1)`;
            } else {
                // 10% chans f√∂r vit
                particleColor = `rgba(255, 255, 255, 1)`;
            }
            
            hitEffect.particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                size: Math.random() * particleSize + 2,
                color: particleColor,
                lifetime: 0,
                maxLifetime: Math.random() * 40 + 15
            });
        }
        
        // L√§gg till i den globala arrayen
        hitEffects.push(hitEffect);
    }
    
    // 3. L√§gg till en funktion f√∂r att uppdatera och rendera alla hitEffects
    function updateHitEffects() {
        for (let i = hitEffects.length - 1; i >= 0; i--) {
            const effect = hitEffects[i];
            let effectActive = false;
            
            // Rita initial blixt/ring
            if (effect.flash && effect.flash.size < effect.flash.maxSize) {
                effectActive = true;
                effect.flash.size += effect.flash.growSpeed;
                effect.flash.alpha *= 0.9;
                
                ctx.beginPath();
                ctx.arc(effect.flash.x, effect.flash.y, effect.flash.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 200, 50, ${effect.flash.alpha})`;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(effect.flash.x, effect.flash.y, effect.flash.size * 0.6, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 200, ${effect.flash.alpha * 1.2})`;
                ctx.fill();
            }
            
            // Uppdatera och rita partiklar
            for (let j = 0; j < effect.particles.length; j++) {
                const particle = effect.particles[j];
                
                // Uppdatera position
                particle.x += particle.vx;
                particle.y += particle.vy;
                
                // L√§gg till lite resistans
                particle.vx *= 0.98;
                particle.vy *= 0.98;
                
                // Uppdatera livstid
                particle.lifetime++;
                
                // Kontrollera om partikeln fortfarande lever
                if (particle.lifetime < particle.maxLifetime) {
                    effectActive = true;
                    
                    // Rita partikeln med avtagande opacitet
                    const opacity = 1 - (particle.lifetime / particle.maxLifetime);
                    ctx.fillStyle = particle.color.replace('1)', `${opacity})`);
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Ta bort effekten om alla partiklar har f√∂rsvunnit
            if (!effectActive) {
                hitEffects.splice(i, 1);
            }
        }
    }
    
    // Huvudspelloopen
    function gameLoop(timestamp) {
        // Ber√§kna deltaTime i sekunder (f√∂r enklare ber√§kningar)
        if (!lastTime) lastTime = timestamp;
        deltaTime = (timestamp - lastTime) / 1000; // Konvertera till sekunder
        
        // S√§tt en maxgr√§ns f√∂r deltaTime f√∂r att undvika extrema v√§rden vid tabbyten etc.
        if (deltaTime > 0.1) deltaTime = 0.1;
        
        lastTime = timestamp;
        
        // Rensa sk√§rmen
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Uppdatera och rita stj√§rnor
        updateStars();
        drawStars();
        
        // Uppdatera explosionseffekter
        updateHitEffects();
        
        // Hantera speltillst√•nd
        if (!gameState.gameOver) {
            // Uppdatera
            updatePlayer();
            updateBullets();
            updateEnemies();
            updatePowerUps();
            updateTurrets();
            updateCombo();
            checkCollisions();
            checkPlayerCollisions();
            
            // Rita
            drawPowerUps();
            drawEnemies();
            drawBullets();
            drawTurrets();
            drawPlayer();
            
            // Visa niv√•meddelande om aktivt
            if (levelMessageTimer > 0) {
                ctx.fillStyle = '#ffffff';
                ctx.font = '24px Arial Bold';
                ctx.textAlign = 'center';
                ctx.fillText(levelMessage, canvas.width / 2, canvas.height / 2 - 100);
                
                levelMessageTimer--;
                
                // √Öterst√§ll textjustering
                ctx.textAlign = 'left';
            }
            
            // Rita kombo-meddelande om aktivt
            if (showComboMessage) {
                ctx.textAlign = 'center';
                ctx.font = '24px Arial Bold';
                
                // Best√§m f√§rg baserat p√• kombo-storlek
                let comboColor;
                if (comboCount >= 10) comboColor = '#ff00ff'; // Lila f√∂r stora kombos
                else if (comboCount >= 7) comboColor = '#ff0000'; // R√∂d f√∂r bra kombos
                else if (comboCount >= 5) comboColor = '#ffaa00'; // Orange f√∂r ok kombos
                else comboColor = '#ffff00'; // Gul f√∂r sm√• kombos
                
                ctx.fillStyle = comboColor;
                ctx.fillText(`${comboCount}x KOMBO! +${comboPoints}`, canvas.width / 2, canvas.height / 2 - 50);
                
                // √Öterst√§ll textjustering
                ctx.textAlign = 'left';
            }
            
            // Rita achievement-meddelande om aktivt
            if (showAchievementMessage && currentAchievement) {
                ctx.textAlign = 'center';
                ctx.fillStyle = '#4fc3f7';
                ctx.font = '20px Arial Bold';
                ctx.fillText(`${currentAchievement.icon} PRESTATION UPPL√ÖST! ${currentAchievement.icon}`, canvas.width / 2, canvas.height / 2 + 20);
                ctx.font = '24px Arial Bold';
                ctx.fillText(`${currentAchievement.title}`, canvas.width / 2, canvas.height / 2 + 50);
                ctx.font = '16px Arial';
                ctx.fillText(`${currentAchievement.description}`, canvas.width / 2, canvas.height / 2 + 75);
                ctx.fillText(`+100 po√§ng`, canvas.width / 2, canvas.height / 2 + 95);
                
                // √Öterst√§ll textjustering
                ctx.textAlign = 'left';
            }
            
            // Rita utmaningsinformation
            if (activeChallenge || (challengeCompleted && challengeMessageTimer > 0)) {
                ctx.textAlign = 'right';
                ctx.font = '16px Arial';
                
                if (activeChallenge) {
                    // Visa aktiv utmaning
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillText(`Utmaning: ${activeChallenge.type}`, canvas.width - 20, 30);
                    
                    // Rita framstegsindikator
                    const progressPercent = challengeProgress / activeChallenge.target;
                    const progressWidth = 150;
                    
                    ctx.fillStyle = '#333333';
                    ctx.fillRect(canvas.width - 20 - progressWidth, 40, progressWidth, 10);
                    
                    ctx.fillStyle = '#ffcc00';
                    ctx.fillRect(canvas.width - 20 - progressWidth, 40, progressWidth * progressPercent, 10);
                    
                    // Visa tid kvar
                    const secondsLeft = Math.ceil(challengeTimer / 60);
                    ctx.fillText(`Tid kvar: ${secondsLeft}s`, canvas.width - 20, 70);
                } else if (challengeCompleted && challengeMessageTimer > 0) {
                    // Visa meddelande om klarad utmaning
                    ctx.fillStyle = '#00ff00';
                    ctx.fillText(`Utmaning klarad! +${activeChallenge ? activeChallenge.reward : 200} po√§ng`, canvas.width - 20, 30);
                }
                
                // √Öterst√§ll textjustering
                ctx.textAlign = 'left';
            }
            
            // Visa statistik
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'left';
            ctx.font = '16px Arial';
            ctx.fillText(`Po√§ng: ${gameState.score}`, 10, 30);
            ctx.fillText(`Liv: ${gameState.lives}`, 10, 60);
            ctx.fillText(`Niv√•: ${gameState.level}`, 10, 90);
            
            // Visa aktiva power-ups
            let powerUpY = 120;
            if (player.powerUps.doubleFire) {
                ctx.fillText("Dubbel eld aktiv", 10, powerUpY);
                powerUpY += 25;
            }
            if (player.powerUps.fastFire) {
                ctx.fillText("Snabb eld aktiv", 10, powerUpY);
                powerUpY += 25;
            }
            if (player.powerUps.shield) {
                ctx.fillText("Sk√∂ld aktiv", 10, powerUpY);
                powerUpY += 25;
            }
            if (player.powerUps.autoTurret) {
                ctx.fillText("Auto-turrets aktiva", 10, powerUpY);
                powerUpY += 25;
            }
            if (player.powerUps.piercingShots) {
                ctx.fillText("Genomtr√§ngande skott aktiva", 10, powerUpY);
            }
        } else {
            // Rita game over-sk√§rmen
            drawGameOver();
            
            // Kontrollera om spelaren klickar f√∂r att starta om
            if (keys[' '] || keys['Space']) {
                // Innan spelet startas om, skicka po√§ng till parent om det finns
                if (window.parent && window.parent !== window) {
                    try {
                        // F√∂r att undvika s√§kerhetsfel, anv√§nd postMessage ist√§llet f√∂r direkt funktionsanrop
                        window.parent.postMessage({
                            type: 'gameOver',
                            score: gameState.score
                        }, '*');
                    } catch (e) {
                        console.error('Kunde inte meddela parent om game over:', e);
                    }
                }
                
                // √Öterst√§ll spelet
                resetGame();
            }
        }
        
        // Anropa checkAchievements-funktionen i gameLoop, efter updateCombo
        checkAchievements();
        updateChallenge();
        
        // Forts√§tt loopen
        requestAnimationFrame(gameLoop);
    }
    
    // √Öterst√§ll startGame-funktionen
    function startGame() {
        createStars();
        requestAnimationFrame(gameLoop);
    }

    // Kalla p√• startGame ist√§llet f√∂r att anropa gameLoop direkt
    startGame();
    </script>
</body>
</html>